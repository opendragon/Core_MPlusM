% File: maxboxmacros.mp% Define colours that we need:color yellow;yellow = red + green;% Define gap between inner box and outer box:numeric bandThick;bandThick := 4;pair bandInside, bandHollow;bandInside := (0, bandThick);bandHollow := (0.5bandThick, 0);% Define spacing and gaps around pins:numeric bspace, dspace, poffset, cspace, lwidth, wslop;bspace := 2;dspace := 4;pspace := 20;poffset := 6;cspace := 1.5;lwidth := 0.8;wslop := 10;pair corr;pair ci[][];pair co[][];% Define the macros:%% Derived from boxes.mp, adding minimum size arguments.vardef boxitmin@#(text tt)(expr wide, high) =  save tb, lr;  numeric tb, lr;  beginbox_("boxpath_","sizebox_",@#,tt);  generic_declare(pair) _n.sw, _n.s, _n.se, _n.e, _n.ne, _n.n, _n.nw, _n.w;  0 = xpart (@#nw-@#sw) = ypart(@#se-@#sw);  0 = xpart(@#ne-@#se) = ypart(@#ne-@#nw);  @#w = .5[@#nw,@#sw];  @#s = .5[@#sw,@#se];  @#e = .5[@#ne,@#se];  @#n = .5[@#ne,@#nw];  tb := ypart(urcorner pic_@# - llcorner pic_@#);  if (tb < high):    tb := high;  fi  lr := xpart(urcorner pic_@# - llcorner pic_@#);  if (lr < wide):    lr := wide;  fi  @#ne-@#c = @#c-@#sw = (@#dx,@#dy) + 0.5*(lr,tb);  endbox_(clearb_,@#);enddef;vardef qic_mac_ suffix $ =  fixsize($); fixpos($);  save noff;  pair noff;  noff := (xpart($sw-(corr+llcorner pic_$))+$dx, ypart($off));  pic_$ shifted noffenddef;vardef pic suffix $ = qic_mac_ $ enddef;def drawboxedm(text tt) =         % Draw each box  fixsize(tt); fixpos(tt);  forsuffixes ss=tt: draw qic_mac_.ss; draw bpath.ss; endforenddef;def drawunboxedm(text tt) =       % Draw contents of each box  fixsize(tt); fixpos(tt);  forsuffixes ss=tt: draw qic_mac_.ss; endforenddef;def create_inside_box(expr pp, nin, nout) =  begingroup	% Create the text box:	numeric np, wid;	if nin > nout:	  np := nin;	else:	  np := nout;	fi	wid := dspace*(2*np + 0.75*(np-1)) + wslop;    boxitmin.obj(pp)(wid, 0);    obj.dx = 0;    obj.dy = bspace;    boxit.sur();    sur.nw = obj.nw + bandInside;    sur.ne = obj.ne + bandInside;    sur.sw = obj.sw - bandInside;    sur.se = obj.se - bandInside;    	% Create inlets:	for ii = 1 upto nin:	  circleit.in[ii](qn[ii]);	  in[ii].dx = in[ii].dy = cspace;	endfor;	pair deli;	for ii = 1 upto (nin - 1):	   in[ii + 1].c - in[ii].c = deli;	endfor;	if nin > 0:	  in[1].s = sur.nw + (dspace, pspace);	fi	if nin > 1:	  in[nin].s = sur.ne + (-dspace, pspace);	fi		% Create outlets:	for ii = 1 upto nout:	  circleit.out[ii](qn[ii]);	  out[ii].dx = out[ii].dy = cspace;	endfor;	pair delo;	for ii = 1 upto (nout - 1):	  out[ii + 1].c - out[ii].c = delo;	endfor;	if nout > 0:	  out[1].n = sur.sw + (dspace, -pspace);	fi	if nout > 1:	  out[nout].n = sur.se + (-dspace, -pspace);	fi		% Render the boxes:	fill bpath sur withcolor yellow;	drawboxed(sur);	unfill bpath obj;	corr := (0,0);	drawboxedm(obj);		% Draw the inlets and outlets:	pickup pencircle scaled 0.5pt;	for ii = 1 upto nin:	  drawboxed(in[ii]);	endfor;	for ii = 1 upto nout:	  drawboxed(out[ii]);	endfor;	pickup defaultpen;	% Draw inlet and outlet pins:	path hi;	numeric le, re, lc, rc, te, th, be, bh;	   	for ii = 1 upto nin:	  le := xpart in[ii].c - dspace;	  re := xpart in[ii].c + dspace;	  lc := xpart in[ii].c - lwidth;	  rc := xpart in[ii].c + lwidth;	  te := ypart in[ii].c - poffset;	  th := ypart sur.n;	  hi := (le, ypart obj.n) -- (re, ypart obj.n) -- (re, th) -- (rc, th) --	              (rc, te) -- (lc, te) -- (lc, th) -- (le, th) -- cycle;	  fill hi withcolor black;	  draw hi;	endfor;	for ii = 1 upto nout:	  le := xpart out[ii].c - dspace;	  re := xpart out[ii].c + dspace;	  lc := xpart out[ii].c - lwidth;	  rc := xpart out[ii].c + lwidth;	  be := ypart out[ii].c + poffset;	  bh := ypart sur.s;	  hi := (le, ypart obj.s) -- (re, ypart obj.s) -- (re, bh) -- (rc, bh) --	              (rc, be) -- (lc, be) -- (lc, bh) -- (le, bh) -- cycle;	  fill hi withcolor black;	  draw hi;	endfor;  endgroupenddef;def create_inside_box_no_pins(expr ll, name, nin, nout, tag) =  begingroup	numeric np, wid;	if nin > nout:	  np := nin;	else:	  np := nout;	fi	wid := dspace*(2*np + 0.75*(np-1)) + wslop;    boxitmin.obj[tag](name)(wid, 0);    obj[tag].dx = 0;    obj[tag].dy = bspace;    boxit.sur[tag]();    sur[tag].nw = obj[tag].nw + bandInside;    sur[tag].ne = obj[tag].ne + bandInside;    sur[tag].sw = obj[tag].sw - bandInside;    sur[tag].se = obj[tag].se - bandInside;    sur[tag].sw = ll;    	% Create inlets:	pair deli;	for ii = 1 upto (nin - 1):	  ci[tag][ii + 1] - ci[tag][ii] = deli;	endfor;	if nin > 0:	  ci[tag][1] = sur[tag].nw + (dspace, -0.5bandThick);	fi	if nin > 1:	  ci[tag][nin] = sur[tag].ne + (-dspace, -0.5bandThick);	fi		% Create outlets:	pair delo;	for ii = 1 upto (nout - 1):	  co[tag][ii + 1] - co[tag][ii] = delo;	endfor;	if nout > 0:	  co[tag][1] = sur[tag].sw + (dspace, 0.5bandThick);	fi	if nout > 1:	  co[tag][nout] = sur[tag].se + (-dspace, 0.5bandThick);	fi		% Render the boxes:	fill bpath sur[tag] withcolor yellow;	drawboxed(sur[tag]);	unfill bpath obj[tag];	corr := (0,0);	drawboxedm(obj[tag]);		% Draw inlet and outlet pins:	path hi;	numeric le, re, th, bh;	   	for ii = 1 upto nin:	  le := xpart ci[tag][ii] - dspace;	  re := xpart ci[tag][ii] + dspace;	  th := ypart sur[tag].n;	  hi := (le, ypart obj[tag].n) -- (re, ypart obj[tag].n) -- (re, th) -- (le, th) -- cycle;	  fill hi withcolor black;	  draw hi;	endfor;	for ii = 1 upto nout:	  le := xpart co[tag][ii] - dspace;	  re := xpart co[tag][ii] + dspace;	  bh := ypart sur[tag].s;	  hi := (le, ypart obj[tag].s) -- (re, ypart obj[tag].s) -- (re, bh) -- (le, bh) -- cycle;	  fill hi withcolor black;	  draw hi;	endfor;  endgroupenddef;def create_hollow_box(expr ll, name, nin, nout, tag) =  begingroup	% Create the text box:	numeric np, wid;	if nin > nout:	  np := nin;	else:	  np := nout;	fi	wid := dspace*(2*np + 0.75*(np-1)) + wslop;    boxitmin.obj[tag](name)(wid, 0);    obj[tag].dx = 0;    obj[tag].dy = bspace;    boxit.sur[tag]();    sur[tag].nw = obj[tag].nw + bandInside - bandHollow;    sur[tag].ne = obj[tag].ne + bandInside + bandHollow;    sur[tag].sw = obj[tag].sw - (bandInside + bandHollow);    sur[tag].se = obj[tag].se + bandHollow - bandInside;    sur[tag].sw = ll;    	% Create inlets:	pair deli;	for ii = 1 upto (nin - 1):	  ci[tag][ii + 1] - ci[tag][ii] = deli;	endfor;	if nin > 0:	  ci[tag][1] = sur[tag].nw + (dspace, -0.5bandThick);	fi	if nin > 1:	  ci[tag][nin] = sur[tag].ne + (-dspace, -0.5bandThick);	fi		% Create outlets:	pair delo;	for ii = 1 upto (nout - 1):	  co[tag][ii + 1] - co[tag][ii] = delo;	endfor;	if nout > 0:	  co[tag][1] = sur[tag].sw + (dspace, 0.5bandThick);	fi	if nout > 1:	  co[tag][nout] = sur[tag].se + (-dspace, 0.5bandThick);	fi		% Render the boxes:	drawboxed(sur[tag]);	unfill bpath obj[tag];	corr := bandHollow;	drawunboxedm(obj[tag]);		% Draw inlet and outlet pins:	path hi;	numeric le, re, th, bh;	   	for ii = 1 upto nin:	  le := xpart ci[tag][ii] - dspace;	  re := xpart ci[tag][ii] + dspace;	  th := ypart sur[tag].n;	  hi := (le, ypart obj[tag].n) -- (re, ypart obj[tag].n) -- (re, th) -- (le, th) -- cycle;	  fill hi withcolor black;	  draw hi;	endfor;	for ii = 1 upto nout:	  le := xpart co[tag][ii] - dspace;	  re := xpart co[tag][ii] + dspace;	  bh := ypart sur[tag].s;	  hi := (le, ypart obj[tag].s) -- (re, ypart obj[tag].s) -- (re, bh) -- (le, bh) -- cycle;	  fill hi withcolor black;	  draw hi;	endfor;  endgroupenddef;def drawboxedc(text tt, cc) =         % Draw each box  fixsize(tt); fixpos(tt);  forsuffixes ss=tt: draw pic_mac_.ss withcolor cc; draw bpath.ss; endforenddef;vardef drawshadowed(text tt) =  color cc;  fixsize(tt);  forsuffixes ss = tt:  	fill bpath.ss shifted (1,-1);  	unfill bpath.ss;  	cc := black;  	if ss.col = 1:  	  cc := red;  	fi  	if ss.col = 2:  	  cc := green;  	fi  	if ss.col = 3:  	  cc := blue;  	fi  	drawboxedc(ss)(cc);  endforenddef;vardef cuta(suffix aa,bb) expr pp =  drawarrow pp cutbefore bpath.aa cutafter bpath.bb;  point 0.5*length pp of ppenddef;vardef self@# expr pp =  cuta(@#,@#) @#.c{curl0}..@#.c+pp..{curl0}@#.cenddef;% $Log: maxboxmacros.mp,v $% Revision 1.4  2006/07/20 04:47:53  churchoflambda% Re-added the files to record their changes.%% Revision 1.2  2005/08/02 15:07:09  churchoflambda% Added CVS tags; add rail diagrams for pfsm, map1d, map2d, map3d and listen.%